"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/** MKCentral API GET Endpoints
*
* Players (paginated list)
* https://mkcentral.com/api/registry/players
* Options from '{ PlayerFilter } from ../lib/player/PlayerFilter'
*
* Player (profile by Id)
* https://mkcentral.com/api/registry/players/{id}
* No options available, but sub-endpoints:
*   - https://mkcentral.com/api/tournaments/players/placements/{id}
*   - https://mkcentral.com/api/registry/players/{id}/getPlayerTransferHistory
*
* Teams (paginated list)
* https://mkcentral.com/api/registry/teams?is_historical=false&is_active=true&sort_by_newest=false&min_player_count=6&page=1
* No options for now, on the ToDo
*
* Team (profile by Id)
* https://mkcentral.com/api/registry/teams/35
* No options available, but sub-endpoints:
*   - https://mkcentral.com/api/tournaments/teams/placements/{id}
*   - https://mkcentral.com/api/registry/teams/transfers/approved?page=1&team_id={id}
*/
var APIRequest_1 = require("../lib/common/APIRequest");
var readline = __importStar(require("readline"));
var playerIds = [183, 1655, 4187];
var teamIds = [35];
// Parse endpoints from the comment
var endpoints = [
    {
        name: 'Players List',
        url: 'https://mkcentral.com/api/registry/players',
        method: 'GET',
        params: ['PlayerFilter options']
    },
    {
        name: 'Player Profile',
        url: 'https://mkcentral.com/api/registry/players/{id}',
        method: 'GET',
        params: ['id'],
        subEndpoints: [
            'https://mkcentral.com/api/tournaments/players/placements/{id}',
            'https://mkcentral.com/api/registry/players/{id}/getPlayerTransferHistory'
        ]
    },
    {
        name: 'Teams List',
        url: 'https://mkcentral.com/api/registry/teams',
        method: 'GET',
        params: ['is_historical', 'is_active', 'sort_by_newest', 'min_player_count', 'page']
    },
    {
        name: 'Team Profile',
        url: 'https://mkcentral.com/api/registry/teams/{id}',
        method: 'GET',
        params: ['id'],
        subEndpoints: [
            'https://mkcentral.com/api/tournaments/teams/placements/{id}',
            'https://mkcentral.com/api/registry/teams/transfers/approved'
        ]
    }
];
// Analyze response structure
function analyzeEndpointResponse(url, params) {
    return __awaiter(this, void 0, void 0, function () {
        var response, data, error_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    return [4 /*yield*/, (0, APIRequest_1.fetchHttpsContent)(url)];
                case 1:
                    response = _a.sent();
                    data = JSON.parse(response);
                    return [2 /*return*/, extractFieldDefinitions(data)];
                case 2:
                    error_1 = _a.sent();
                    console.error("Error fetching ".concat(url, ":"), error_1);
                    return [2 /*return*/, null];
                case 3: return [2 /*return*/];
            }
        });
    });
}
// Recursively extract field definitions
function extractFieldDefinitions(obj, prefix) {
    if (prefix === void 0) { prefix = ''; }
    var fields = {};
    if (obj === null || obj === undefined) {
        return fields;
    }
    if (Array.isArray(obj)) {
        fields[prefix || 'root'] = 'array';
        if (obj.length > 0) {
            var childFields = extractFieldDefinitions(obj[0], "".concat(prefix, "[0]"));
            Object.assign(fields, childFields);
        }
    }
    else if (typeof obj === 'object') {
        for (var _i = 0, _a = Object.entries(obj); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            var fieldPath = prefix ? "".concat(prefix, ".").concat(key) : key;
            if (value === null) {
                fields[fieldPath] = 'null';
            }
            else if (Array.isArray(value)) {
                fields[fieldPath] = 'array';
                if (value.length > 0) {
                    var childFields = extractFieldDefinitions(value[0], "".concat(fieldPath, "[0]"));
                    Object.assign(fields, childFields);
                }
            }
            else if (typeof value === 'object') {
                fields[fieldPath] = 'object';
                var childFields = extractFieldDefinitions(value, fieldPath);
                Object.assign(fields, childFields);
            }
            else {
                fields[fieldPath] = typeof value;
            }
        }
    }
    else {
        fields[prefix || 'root'] = typeof obj;
    }
    return fields;
}
// Convert flat field definitions to hierarchical structure for display
function formatFieldsHierarchically(fields) {
    var output = [];
    var processed = new Set();
    // Sort fields by path to ensure parent fields come before children
    var sortedFields = Object.entries(fields).sort(function (_a, _b) {
        var a = _a[0];
        var b = _b[0];
        return a.localeCompare(b);
    });
    var _loop_1 = function (path, type) {
        if (processed.has(path))
            return "continue";
        // Calculate indentation based on path depth
        var parts = path.split(/[\.\[\]]+/).filter(function (p) { return p && p !== '0'; });
        var indent = '  '.repeat(parts.length - 1);
        // Clean up the display name
        var displayName = parts[parts.length - 1] || 'root';
        // Check if this is an array or object with children
        var hasChildren = sortedFields.some(function (_a) {
            var p = _a[0];
            return p !== path && p.startsWith(path) && (p.startsWith(path + '.') || p.startsWith(path + '['));
        });
        if (type === 'array') {
            output.push("".concat(indent).concat(displayName, ": ").concat(type));
            // Mark array index paths as processed since we'll show them as part of the array
            sortedFields.forEach(function (_a) {
                var p = _a[0];
                if (p.startsWith(path + '[0]')) {
                    processed.add(path + '[0]');
                }
            });
        }
        else if (type === 'object' && hasChildren) {
            output.push("".concat(indent).concat(displayName, ": ").concat(type));
        }
        else {
            output.push("".concat(indent).concat(displayName, ": ").concat(type));
        }
        processed.add(path);
    };
    for (var _i = 0, sortedFields_1 = sortedFields; _i < sortedFields_1.length; _i++) {
        var _a = sortedFields_1[_i], path = _a[0], type = _a[1];
        _loop_1(path, type);
    }
    return output;
}
// Create readline interface for CLI
var rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});
// Helper function to prompt user
function prompt(question) {
    return new Promise(function (resolve) {
        rl.question(question, function (answer) {
            resolve(answer.trim());
        });
    });
}
// Display menu and get selection
function showMainMenu() {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    console.log('\n=== MKCentral API Endpoint Analyzer ===');
                    console.log('1. Players List');
                    console.log('2. Player Profile');
                    console.log('3. Teams List');
                    console.log('4. Team Profile');
                    console.log('5. Crawl Players (Build comprehensive definition)');
                    console.log('6. Crawl Teams (Build comprehensive definition)');
                    console.log('7. Exit');
                    return [4 /*yield*/, prompt('\nSelect an option (1-7): ')];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    });
}
// Show ID selection menu for players
function selectPlayerId() {
    return __awaiter(this, void 0, void 0, function () {
        var choice, choiceNum, customId;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    console.log('\n=== Select Player ID ===');
                    playerIds.forEach(function (id, index) {
                        console.log("".concat(index + 1, ". Player ").concat(id));
                    });
                    console.log("".concat(playerIds.length + 1, ". Enter custom ID"));
                    console.log("".concat(playerIds.length + 2, ". Back to main menu"));
                    return [4 /*yield*/, prompt("\nSelect an option (1-".concat(playerIds.length + 2, "): "))];
                case 1:
                    choice = _a.sent();
                    choiceNum = parseInt(choice);
                    if (!(choiceNum >= 1 && choiceNum <= playerIds.length)) return [3 /*break*/, 2];
                    return [2 /*return*/, playerIds[choiceNum - 1]];
                case 2:
                    if (!(choiceNum === playerIds.length + 1)) return [3 /*break*/, 4];
                    return [4 /*yield*/, prompt('Enter player ID: ')];
                case 3:
                    customId = _a.sent();
                    return [2 /*return*/, parseInt(customId) || null];
                case 4: return [2 /*return*/, null];
            }
        });
    });
}
// Show ID selection menu for teams
function selectTeamId() {
    return __awaiter(this, void 0, void 0, function () {
        var choice, choiceNum, customId;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    console.log('\n=== Select Team ID ===');
                    teamIds.forEach(function (id, index) {
                        console.log("".concat(index + 1, ". Team ").concat(id));
                    });
                    console.log("".concat(teamIds.length + 1, ". Enter custom ID"));
                    console.log("".concat(teamIds.length + 2, ". Back to main menu"));
                    return [4 /*yield*/, prompt("\nSelect an option (1-".concat(teamIds.length + 2, "): "))];
                case 1:
                    choice = _a.sent();
                    choiceNum = parseInt(choice);
                    if (!(choiceNum >= 1 && choiceNum <= teamIds.length)) return [3 /*break*/, 2];
                    return [2 /*return*/, teamIds[choiceNum - 1]];
                case 2:
                    if (!(choiceNum === teamIds.length + 1)) return [3 /*break*/, 4];
                    return [4 /*yield*/, prompt('Enter team ID: ')];
                case 3:
                    customId = _a.sent();
                    return [2 /*return*/, parseInt(customId) || null];
                case 4: return [2 /*return*/, null];
            }
        });
    });
}
// Analyze and display endpoint data
function analyzeAndDisplay(url, name) {
    return __awaiter(this, void 0, void 0, function () {
        var fields, formatted;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    console.log("\n=== Analyzing ".concat(name, " ==="));
                    console.log("URL: ".concat(url));
                    console.log('Fetching data...\n');
                    return [4 /*yield*/, analyzeEndpointResponse(url)];
                case 1:
                    fields = _a.sent();
                    if (fields) {
                        console.log('Field Definitions:');
                        formatted = formatFieldsHierarchically(fields);
                        formatted.forEach(function (line) { return console.log(line); });
                    }
                    else {
                        console.log('Failed to fetch or parse data.');
                    }
                    return [4 /*yield*/, prompt('\nPress Enter to continue...')];
                case 2:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
// Enhanced field extraction for crawling
function extractFieldsWithValues(obj, prefix, collectValues) {
    if (prefix === void 0) { prefix = ''; }
    if (collectValues === void 0) { collectValues = false; }
    var fields = new Map();
    if (obj === null || obj === undefined) {
        return fields;
    }
    if (Array.isArray(obj)) {
        var info = {
            types: new Map([['array', 1]]),
            totalOccurrences: 1
        };
        fields.set(prefix || 'root', info);
        if (obj.length > 0) {
            var childFields = extractFieldsWithValues(obj[0], "".concat(prefix, "[0]"), collectValues);
            childFields.forEach(function (info, path) { return fields.set(path, info); });
        }
    }
    else if (typeof obj === 'object') {
        for (var _i = 0, _a = Object.entries(obj); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            var fieldPath = prefix ? "".concat(prefix, ".").concat(key) : key;
            if (value === null) {
                fields.set(fieldPath, {
                    types: new Map([['null', 1]]),
                    totalOccurrences: 1
                });
            }
            else if (Array.isArray(value)) {
                fields.set(fieldPath, {
                    types: new Map([['array', 1]]),
                    totalOccurrences: 1
                });
                if (value.length > 0) {
                    var childFields = extractFieldsWithValues(value[0], "".concat(fieldPath, "[0]"), collectValues);
                    childFields.forEach(function (info, path) { return fields.set(path, info); });
                }
            }
            else if (typeof value === 'object') {
                fields.set(fieldPath, {
                    types: new Map([['object', 1]]),
                    totalOccurrences: 1
                });
                var childFields = extractFieldsWithValues(value, fieldPath, collectValues);
                childFields.forEach(function (info, path) { return fields.set(path, info); });
            }
            else {
                var type = typeof value;
                var info = {
                    types: new Map([[type, 1]]),
                    totalOccurrences: 1
                };
                // Collect role values specifically
                if (collectValues && (key === 'role' || fieldPath.includes('role'))) {
                    info.uniqueValues = new Set([value]);
                }
                fields.set(fieldPath, info);
            }
        }
    }
    else {
        fields.set(prefix || 'root', {
            types: new Map([[typeof obj, 1]]),
            totalOccurrences: 1
        });
    }
    return fields;
}
// Merge field information from multiple sources
function mergeFieldInfo(target, source) {
    source.forEach(function (sourceInfo, path) {
        if (target.has(path)) {
            var targetInfo_1 = target.get(path);
            targetInfo_1.totalOccurrences++;
            // Merge type occurrences
            sourceInfo.types.forEach(function (count, type) {
                targetInfo_1.types.set(type, (targetInfo_1.types.get(type) || 0) + count);
            });
            // Merge unique values if present
            if (sourceInfo.uniqueValues && targetInfo_1.uniqueValues) {
                sourceInfo.uniqueValues.forEach(function (val) { return targetInfo_1.uniqueValues.add(val); });
            }
            else if (sourceInfo.uniqueValues) {
                targetInfo_1.uniqueValues = new Set(sourceInfo.uniqueValues);
            }
        }
        else {
            target.set(path, {
                types: new Map(sourceInfo.types),
                totalOccurrences: 1,
                uniqueValues: sourceInfo.uniqueValues ? new Set(sourceInfo.uniqueValues) : undefined
            });
        }
    });
}
// Helper to determine the final type string from collected type information
function determineTypeString(info, successCount) {
    var types = Array.from(info.types.keys()).filter(function (t) { return t !== 'null'; });
    var hasNull = info.types.has('null');
    var coverage = ((info.totalOccurrences / successCount) * 100).toFixed(1);
    // If field doesn't appear in all objects, it's optional (can be undefined)
    var isOptional = info.totalOccurrences < successCount;
    var typeStr;
    if (types.length === 0) {
        // Only null values found
        typeStr = 'null';
    }
    else if (types.length === 1) {
        // Single type (plus possibly null)
        typeStr = types[0];
        if (hasNull) {
            typeStr += ' | null';
        }
    }
    else {
        // Multiple types found
        typeStr = types.join(' | ');
        if (hasNull) {
            typeStr += ' | null';
        }
    }
    // Add coverage and optional indicator
    var suffix = " (".concat(coverage, "%)");
    if (isOptional) {
        suffix += ' [optional]';
    }
    return typeStr + suffix;
}
// Configure crawl parameters
function configureCrawl(type) {
    return __awaiter(this, void 0, void 0, function () {
        var maxId, choice, _a, startId, _b, endId, _c, sampleSize, _d, randomChoice, confirm_1, resumeChoice, resumeId, _e;
        return __generator(this, function (_f) {
            switch (_f.label) {
                case 0:
                    maxId = type === 'player' ? 78550 : 3380;
                    console.log("\n=== Configure ".concat(type, " crawl ==="));
                    console.log("Maximum ID: ".concat(maxId));
                    console.log('1. Quick sample (10 random IDs)');
                    console.log('2. Medium sample (50 random IDs)');
                    console.log('3. Large sample (100 random IDs)');
                    console.log('4. Extra large sample (500 random IDs)');
                    console.log('5. Custom configuration');
                    console.log('6. FULL CRAWL (ALL IDs) - WARNING: This will take a long time!');
                    console.log('7. Back to main menu');
                    return [4 /*yield*/, prompt('\nSelect an option (1-7): ')];
                case 1:
                    choice = _f.sent();
                    _a = choice;
                    switch (_a) {
                        case '1': return [3 /*break*/, 2];
                        case '2': return [3 /*break*/, 3];
                        case '3': return [3 /*break*/, 4];
                        case '4': return [3 /*break*/, 5];
                        case '5': return [3 /*break*/, 6];
                        case '6': return [3 /*break*/, 11];
                    }
                    return [3 /*break*/, 16];
                case 2: return [2 /*return*/, { startId: 1, endId: maxId, sampleSize: 10, randomSample: true }];
                case 3: return [2 /*return*/, { startId: 1, endId: maxId, sampleSize: 50, randomSample: true }];
                case 4: return [2 /*return*/, { startId: 1, endId: maxId, sampleSize: 100, randomSample: true }];
                case 5: return [2 /*return*/, { startId: 1, endId: maxId, sampleSize: 500, randomSample: true }];
                case 6:
                    _b = parseInt;
                    return [4 /*yield*/, prompt("Enter start ID (1-".concat(maxId, "): "))];
                case 7:
                    startId = _b.apply(void 0, [_f.sent()]) || 1;
                    _c = parseInt;
                    return [4 /*yield*/, prompt("Enter end ID (".concat(startId, "-").concat(maxId, "): "))];
                case 8:
                    endId = _c.apply(void 0, [_f.sent()]) || maxId;
                    _d = parseInt;
                    return [4 /*yield*/, prompt("Enter sample size (1-".concat(Math.min(endId - startId + 1, 1000), "): "))];
                case 9:
                    sampleSize = _d.apply(void 0, [_f.sent()]) || 10;
                    return [4 /*yield*/, prompt('Use random sampling? (y/n): ')];
                case 10:
                    randomChoice = _f.sent();
                    return [2 /*return*/, {
                            startId: Math.max(1, Math.min(startId, maxId)),
                            endId: Math.min(endId, maxId),
                            sampleSize: Math.min(sampleSize, endId - startId + 1),
                            randomSample: randomChoice.toLowerCase() === 'y'
                        }];
                case 11:
                    // Full crawl warning and confirmation
                    console.log('\n⚠️  WARNING: Full Crawl Selected ⚠️');
                    console.log("This will attempt to fetch ".concat(maxId, " ").concat(type, " records."));
                    console.log("Estimated time: ".concat(Math.ceil(maxId * 0.1 / 60), " minutes (at 100ms per request)"));
                    console.log('This may consume significant bandwidth and could trigger rate limiting.');
                    return [4 /*yield*/, prompt('\nAre you sure you want to proceed? (yes/no): ')];
                case 12:
                    confirm_1 = _f.sent();
                    if (confirm_1.toLowerCase() !== 'yes') {
                        console.log('Full crawl cancelled.');
                        return [2 /*return*/, null];
                    }
                    return [4 /*yield*/, prompt('Do you want to resume from a specific ID? (y/n): ')];
                case 13:
                    resumeChoice = _f.sent();
                    resumeId = 1;
                    if (!(resumeChoice.toLowerCase() === 'y')) return [3 /*break*/, 15];
                    _e = parseInt;
                    return [4 /*yield*/, prompt("Enter starting ID (1-".concat(maxId, "): "))];
                case 14:
                    resumeId = _e.apply(void 0, [_f.sent()]) || 1;
                    _f.label = 15;
                case 15: return [2 /*return*/, {
                        startId: resumeId,
                        endId: maxId,
                        sampleSize: maxId - resumeId + 1,
                        randomSample: false
                    }];
                case 16: return [2 /*return*/, null];
            }
        });
    });
}
// Generate IDs for crawling
function generateCrawlIds(config) {
    var ids = [];
    if (config.randomSample) {
        var availableIds = new Set();
        for (var i = config.startId; i <= config.endId; i++) {
            availableIds.add(i);
        }
        while (ids.length < config.sampleSize && availableIds.size > 0) {
            var randomIndex = Math.floor(Math.random() * availableIds.size);
            var id = Array.from(availableIds)[randomIndex];
            ids.push(id);
            availableIds.delete(id);
        }
    }
    else {
        var step = Math.max(1, Math.floor((config.endId - config.startId) / config.sampleSize));
        for (var i = config.startId; i <= config.endId && ids.length < config.sampleSize; i += step) {
            ids.push(i);
        }
    }
    return ids.sort(function (a, b) { return a - b; });
}
// Crawl endpoints and collect comprehensive data
function crawlEndpoints(type, config) {
    return __awaiter(this, void 0, void 0, function () {
        var baseUrl, ids, allFields, missingFields, successCount, failCount, isFullCrawl, startTime, lastProgressUpdate, _loop_2, i, totalTime, sortedFields, fieldDefs, roleValues, formatted, mixedTypeFields, alwaysNullFields;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    baseUrl = type === 'player'
                        ? 'https://mkcentral.com/api/registry/players/'
                        : 'https://mkcentral.com/api/registry/teams/';
                    ids = generateCrawlIds(config);
                    allFields = new Map();
                    missingFields = new Map();
                    successCount = 0;
                    failCount = 0;
                    isFullCrawl = !config.randomSample && config.sampleSize > 1000;
                    console.log("\n=== ".concat(isFullCrawl ? 'FULL CRAWL' : 'Crawling', " ").concat(type, "s ==="));
                    console.log("Analyzing ".concat(ids.length, " IDs: ").concat(ids.slice(0, 5).join(', ')).concat(ids.length > 5 ? '...' : ''));
                    if (isFullCrawl) {
                        console.log("Started at: ".concat(new Date().toLocaleString()));
                    }
                    console.log('Progress:');
                    startTime = Date.now();
                    lastProgressUpdate = Date.now();
                    _loop_2 = function (i) {
                        var id, now, elapsed, rate, remaining, eta, response, data, fields_1, error_2, saveChoice;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    id = ids[i];
                                    now = Date.now();
                                    if (isFullCrawl && (now - lastProgressUpdate > 1000 || i === ids.length - 1)) {
                                        elapsed = (now - startTime) / 1000;
                                        rate = successCount / elapsed;
                                        remaining = (ids.length - i) / rate;
                                        eta = new Date(now + remaining * 1000).toLocaleTimeString();
                                        process.stdout.write("\r[".concat(i + 1, "/").concat(ids.length, "] ID: ").concat(id, " | Success: ").concat(successCount, " | Failed: ").concat(failCount, " | Rate: ").concat(rate.toFixed(1), "/s | ETA: ").concat(eta, "    "));
                                        lastProgressUpdate = now;
                                    }
                                    else if (!isFullCrawl) {
                                        process.stdout.write("\r[".concat(i + 1, "/").concat(ids.length, "] Analyzing ").concat(type, " ").concat(id, "... (Success: ").concat(successCount, ", Failed: ").concat(failCount, ")"));
                                    }
                                    _b.label = 1;
                                case 1:
                                    _b.trys.push([1, 3, , 4]);
                                    return [4 /*yield*/, (0, APIRequest_1.fetchHttpsContent)(baseUrl + id)];
                                case 2:
                                    response = _b.sent();
                                    data = JSON.parse(response);
                                    fields_1 = extractFieldsWithValues(data, '', true);
                                    // Track this successful fetch
                                    successCount++;
                                    // Merge field data
                                    mergeFieldInfo(allFields, fields_1);
                                    // Track missing fields for this object
                                    allFields.forEach(function (_, fieldPath) {
                                        if (!fields_1.has(fieldPath)) {
                                            if (!missingFields.has(fieldPath)) {
                                                missingFields.set(fieldPath, 0);
                                            }
                                            missingFields.set(fieldPath, missingFields.get(fieldPath) + 1);
                                        }
                                    });
                                    return [3 /*break*/, 4];
                                case 3:
                                    error_2 = _b.sent();
                                    failCount++;
                                    return [3 /*break*/, 4];
                                case 4: 
                                // Small delay to avoid rate limiting
                                return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(resolve, 100); })];
                                case 5:
                                    // Small delay to avoid rate limiting
                                    _b.sent();
                                    if (!(isFullCrawl && i > 0 && i % 1000 === 0)) return [3 /*break*/, 7];
                                    console.log("\n\nCheckpoint at ID ".concat(id, ": ").concat(successCount, " successful, ").concat(failCount, " failed"));
                                    console.log("Memory usage: ".concat(Math.round(process.memoryUsage().heapUsed / 1024 / 1024), "MB"));
                                    return [4 /*yield*/, prompt('Save intermediate results? (y/n/c to continue without asking): ')];
                                case 6:
                                    saveChoice = _b.sent();
                                    if (saveChoice.toLowerCase() === 'y') {
                                        // Save logic would go here
                                        console.log('Intermediate results would be saved here (not implemented)');
                                    }
                                    else if (saveChoice.toLowerCase() !== 'c') {
                                        // Continue without further prompts
                                    }
                                    _b.label = 7;
                                case 7: return [2 /*return*/];
                            }
                        });
                    };
                    i = 0;
                    _a.label = 1;
                case 1:
                    if (!(i < ids.length)) return [3 /*break*/, 4];
                    return [5 /*yield**/, _loop_2(i)];
                case 2:
                    _a.sent();
                    _a.label = 3;
                case 3:
                    i++;
                    return [3 /*break*/, 1];
                case 4:
                    totalTime = (Date.now() - startTime) / 1000;
                    console.log("\n\nCrawl complete! Success: ".concat(successCount, ", Failed: ").concat(failCount));
                    console.log("Total time: ".concat(Math.floor(totalTime / 60), "m ").concat(Math.floor(totalTime % 60), "s"));
                    console.log("Average rate: ".concat((successCount / totalTime).toFixed(2), " requests/second"));
                    // Display comprehensive results
                    console.log('\n=== Comprehensive Field Definition ===');
                    sortedFields = Array.from(allFields.entries()).sort(function (_a, _b) {
                        var a = _a[0];
                        var b = _b[0];
                        return a.localeCompare(b);
                    });
                    fieldDefs = {};
                    roleValues = new Set();
                    sortedFields.forEach(function (_a) {
                        var path = _a[0], info = _a[1];
                        fieldDefs[path] = determineTypeString(info, successCount);
                        // Collect role values
                        if (info.uniqueValues && path.includes('role')) {
                            info.uniqueValues.forEach(function (val) { return roleValues.add(String(val)); });
                        }
                    });
                    formatted = formatFieldsHierarchically(fieldDefs);
                    formatted.forEach(function (line) { return console.log(line); });
                    // Display role values if this is a player crawl
                    if (type === 'player' && roleValues.size > 0) {
                        console.log('\n=== Discovered Role Values ===');
                        Array.from(roleValues).sort().forEach(function (role) {
                            console.log("  - ".concat(role));
                        });
                    }
                    mixedTypeFields = sortedFields.filter(function (_a) {
                        var _ = _a[0], info = _a[1];
                        return info.types.size > 1;
                    });
                    if (mixedTypeFields.length > 0) {
                        console.log('\n=== Fields with Mixed Types ===');
                        mixedTypeFields.forEach(function (_a) {
                            var path = _a[0], info = _a[1];
                            console.log("  ".concat(path, ":"));
                            info.types.forEach(function (count, type) {
                                var percentage = ((count / info.totalOccurrences) * 100).toFixed(1);
                                console.log("    - ".concat(type, ": ").concat(count, " occurrences (").concat(percentage, "%)"));
                            });
                        });
                    }
                    alwaysNullFields = sortedFields.filter(function (_a) {
                        var _ = _a[0], info = _a[1];
                        return info.types.size === 1 && info.types.has('null');
                    });
                    if (alwaysNullFields.length > 0) {
                        console.log('\n=== Always Null Fields ===');
                        alwaysNullFields.forEach(function (_a) {
                            var path = _a[0];
                            console.log("  - ".concat(path));
                        });
                    }
                    // For full crawls, show more detailed statistics
                    if (isFullCrawl) {
                        console.log('\n=== Full Crawl Statistics ===');
                        console.log("Total IDs attempted: ".concat(ids.length));
                        console.log("Successful fetches: ".concat(successCount, " (").concat(((successCount / ids.length) * 100).toFixed(2), "%)"));
                        console.log("Failed fetches: ".concat(failCount, " (").concat(((failCount / ids.length) * 100).toFixed(2), "%)"));
                        console.log("Total unique fields discovered: ".concat(allFields.size));
                        console.log("Fields with 100% coverage: ".concat(sortedFields.filter(function (_a) {
                            var _ = _a[0], info = _a[1];
                            return info.totalOccurrences === successCount;
                        }).length));
                        console.log("Optional fields: ".concat(sortedFields.filter(function (_a) {
                            var _ = _a[0], info = _a[1];
                            return info.totalOccurrences < successCount;
                        }).length));
                    }
                    return [4 /*yield*/, prompt('\nPress Enter to continue...')];
                case 5:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
// Main CLI loop
function runCLI() {
    return __awaiter(this, void 0, void 0, function () {
        var running, choice, _a, playerId, teamId, playerConfig, teamConfig;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    running = true;
                    _b.label = 1;
                case 1:
                    if (!running) return [3 /*break*/, 26];
                    return [4 /*yield*/, showMainMenu()];
                case 2:
                    choice = _b.sent();
                    _a = choice;
                    switch (_a) {
                        case '1': return [3 /*break*/, 3];
                        case '2': return [3 /*break*/, 5];
                        case '3': return [3 /*break*/, 9];
                        case '4': return [3 /*break*/, 11];
                        case '5': return [3 /*break*/, 15];
                        case '6': return [3 /*break*/, 19];
                        case '7': return [3 /*break*/, 23];
                    }
                    return [3 /*break*/, 24];
                case 3: return [4 /*yield*/, analyzeAndDisplay('https://mkcentral.com/api/registry/players?page=1', 'Players List')];
                case 4:
                    _b.sent();
                    return [3 /*break*/, 25];
                case 5: return [4 /*yield*/, selectPlayerId()];
                case 6:
                    playerId = _b.sent();
                    if (!playerId) return [3 /*break*/, 8];
                    return [4 /*yield*/, analyzeAndDisplay("https://mkcentral.com/api/registry/players/".concat(playerId), "Player ".concat(playerId))];
                case 7:
                    _b.sent();
                    _b.label = 8;
                case 8: return [3 /*break*/, 25];
                case 9: return [4 /*yield*/, analyzeAndDisplay('https://mkcentral.com/api/registry/teams?is_historical=false&is_active=true&sort_by_newest=false&min_player_count=6&page=1', 'Teams List')];
                case 10:
                    _b.sent();
                    return [3 /*break*/, 25];
                case 11: return [4 /*yield*/, selectTeamId()];
                case 12:
                    teamId = _b.sent();
                    if (!teamId) return [3 /*break*/, 14];
                    return [4 /*yield*/, analyzeAndDisplay("https://mkcentral.com/api/registry/teams/".concat(teamId), "Team ".concat(teamId))];
                case 13:
                    _b.sent();
                    _b.label = 14;
                case 14: return [3 /*break*/, 25];
                case 15: return [4 /*yield*/, configureCrawl('player')];
                case 16:
                    playerConfig = _b.sent();
                    if (!playerConfig) return [3 /*break*/, 18];
                    return [4 /*yield*/, crawlEndpoints('player', playerConfig)];
                case 17:
                    _b.sent();
                    _b.label = 18;
                case 18: return [3 /*break*/, 25];
                case 19: return [4 /*yield*/, configureCrawl('team')];
                case 20:
                    teamConfig = _b.sent();
                    if (!teamConfig) return [3 /*break*/, 22];
                    return [4 /*yield*/, crawlEndpoints('team', teamConfig)];
                case 21:
                    _b.sent();
                    _b.label = 22;
                case 22: return [3 /*break*/, 25];
                case 23:
                    running = false;
                    console.log('\nExiting...');
                    return [3 /*break*/, 25];
                case 24:
                    console.log('\nInvalid option. Please try again.');
                    _b.label = 25;
                case 25: return [3 /*break*/, 1];
                case 26:
                    rl.close();
                    return [2 /*return*/];
            }
        });
    });
}
// Replace the old analyzeAllEndpoints function call
// analyzeAllEndpoints().catch(console.error);
// Run the CLI
runCLI().catch(function (error) {
    console.error('Error:', error);
    rl.close();
});
